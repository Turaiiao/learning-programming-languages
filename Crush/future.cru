// Import other module like array and alias a name.
// I very like crush language syntax and I design it.
import 'std' -> [time, http, platform as darwin]

// If I want import all open statement or expression.
// Can not missing the `*` operator because I like it.
import 'test.cru' -> *

// A very simple function like this.
// It is return the max of two numbers.
def max (a: int, b: int) -> int ~>
  return if (a > b) -> a else -> b
end

// This is a lambda expression with function statement.
// It is public in current module.
// If function body only have one statement I can use `=>` operator to appoint it.
// And the `~>` operator illustrate function have many statement in body.
// We should add the `end` statement after execution body.
open var sum = (a: int, b: int) -> int => a + b

// Define a function with lambda expression and it have many statement in body.
// It have three parameter.
// First and second is integer variable that easy to understand it.
// The third parameter is a function type !!
// The third parameter has two integer parameters and an integer is returned.
open var mul = (a: int, b: int, sum: (int, int) -> int) -> int ~>
  // Call third parameter.
  var sum = sum(a, b)

  // Return with `if` expression.
  return if (sum > 100 & sum < 200) -> a * b
    elif (sum > 200) -> a * b + sum
    else -> sum
end

// The Const value illustrate value is fixed and can't move.
open const var a: int = 20
open const var b: flo = 2.

// Magic !!
// Dead cycle.
magic ~>
  // Define a mutable variable.
  // It will catch user input and convert type to integer.
  var mut i = input() as int

  // A guess number program.
  if (a == i) ~>
    println 'You are win !!'
    break
  end
  
  elif (a > i) ->
    println 'Too small.'
  elif (a < i) ->
    println 'Too big.'
end

// We can match some result and handle it.
when (1 + 2) ~>
  1 -> println '1'
  2 -> println '2'
  
  3 ~> 
    println '3'
    println 'OK !!'
  end
  
  4 -> println 'what's the problem ?'
  
  // If they are not the same.
  // The `else` statement like `default` in c language.
  else -> println 'NO !!'
end

// This is a array defintion and it is const value.
// We can appoint the type of variable just use a colon and type.
const var a: list<int> = [1, 2, 3, 4, 5, 6, 7, 8]
// The any object is other types.
const var a: list<any> = [1, false, 2.3, 12, 'test']

// The `for` statement usually are array iterator.
// Use `<-` operator afferent a array or range type.
for (i <- a) ~> if (i % 2 == 0) ->
  println i
end

// Output of even numbers between 0 and 10.
for (i <- 0..10) -> if (i % 2 == 0) -> println i

var mut a = 0

// Have nothing different for `while` statement in other language.
// We just need to known if use `~>` operator that should add `end` statement in end.
while (a < 100) ~>
  if (a % 2 == 0) ->
    println i
  // I like double plus expression, it will add in crush language.
  a ++
end

// The `data` statement like entity in Java.
data Todo -> title: str, date: int

// The `trait` statement like interface type in other language.
// We shoud add some function defintion in interface body.
trait TodoPunchListener ~>
  def success(todo: Todo)
  def haveErr(err: str)
end

// It is public in this module.
// It have one function defintion and will returned an boolean data.
open trait TodoListener ~>
  def punch(listener: TodoPunchListener) -> bool
end

// The `impl` statement is implement type.
// It can implement for other types and it can extend interface type.
// It can define many method on other types.
open impl TodoImpl : TodoListener ~>
  // Use `override` keyword to illustrate this function is extend on interface.
  overlap def punch(listener: TodoPunchListener) -> bool ~>
    if (1 + 1 == 2) -> listener.success(
      new Todo('test', 23)
    )
    else -> 
      listener.haveErr('can not punched !!')
    return true
  end
end

open impl Test : TodoPunchListener ~>
  // First initializtion will execution this statement.
  // Use `this` keyword illustrate current context.
  init -> new TodoImpl().punch(this)

  overlap def success(todo: Todo) => println '\(todo.title) \(todo.date)'
  overlap def haveErr(err: str) => println 'Error: \(err) !!'
end

// Enumeration.
enum Color -> RED, BLUE, GREEN
// This implement is judge two `Color` enumeration type.
// Just use the implement type to illustrate it.
impl Color -> open def equal(x: Color, y: Color) -> bool => x == y

var a = Color.RED

// Error: The variable is not mutable !!
a = Color.BLUE

impl A ~>
  open def show() => println 'show !!'
end

impl B : A ~>
  // Call show method in parent implement.
  init -> super.show()
end

// There will call init method in B implement.
new B()

var a = 23
var b = 45
// This function have one parameter and it is quote value !!
// The parameter a and value will destroyed at function end. 
var c = (a: int) => println a

// There will output the variable a value.
// The variable will be nil after this line.
c(a)

if (a == nil) ->
  println 'a is nil !!'
  
// This function have a borrow parameter it will retain after function destroyed.
var c = (bor a: int) => println a

// Tuple type.
open const var a = (12, 43, 45, 65)

println a.0 + a.1 + a.2 + a.3 // 165

// Function have two borrow values and return the max value.
def max (bor a: int, bor b: int) -> int => if (a > b) -> a else -> b

var mut a = 0
var mut b = []

// This `for` statement has indices and value iterator.
// We just use brackets operator parcel it.
for ((i, v) <- 0..100) ~>
  if (v % 2 == 0) ~>
    // It value is even number that push it to array.
    // Else continue next loop.
    b[i] = v
    continue
  end
  // If is radix number the variable a plus one.
  a ++
end

println a
println b
