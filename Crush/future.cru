// Import other module like use array and it can alias a name.
// I very like crush language syntax and I design it.
import 'std' -> [time, http, platform as darwin]

// If I want import all open statement or expression.
// Can not missing the `*` operator because I like it.
import 'test.cru' -> *

// A very simple function like this.
// It is return the max of two numbers.
func max (a: int, b: int) -> int ~>
  return if (a > b) -> a else -> b
end

// This is a lambda expression with function statement.
// It is open in current module.
// If function body only have one statement I can use `=>` operator to appoint it.
// And the `~>` operator explain function have many statement in body.
open var sum = (a: int, b: int) -> int => a + b

// Declare a function with lambda expression and it have many stmt in body.
// It have three parameter.
// First and second is integer variable that easy to understand it.
// The third parameter is a function declare !!
// The third parameter has two integer parameters and an integer is returned.
open var mul = (a: int, b: int, sum: (int, int) -> int) -> int ~>
  // Call third parameter.
  var sum = sum(a, b)

  return if (sum > 100 & sum < 200) -> a * b
    elif (sum > 200) -> a * b + sum
    else -> sum
end

// The Const value explain value is fixed and can't move.
open const var a: int = 20

// Magic !!
// Dead cycle.
magic ~>
  // Declare a mutable variable.
  // It will catch user input and convert type to integer.
  var mut i = input() as int

  if (a == i) ~>
    println 'You are win !!'
    break
  end
    
  elif (a > i) ->
    println 'Too small.'
  elif (a < i) ->
    println 'Too big.'
end

when (1 + 2) ~>
  1 -> println '1'
  2 -> println '2'
  3 ~> println '3'
       println 'OK !!'
    end
  4 -> println 'what's the problem ?'
  else -> println 'NO !!'
end

const var a: list<int> = [1, 2, 3, 4, 5, 6, 7, 8]

for (i <- a) ~> if (i % 2 == 0) ->
  println i
end

for (i <- 1..8) -> if (i % 2 == 0) -> println i

var mut a = 0

while (a < 100) ~>
  if (a % 2 == 0) ->
    println i
  a += 1
end

open data Todo -> title: string, date: int

trait TodoPunchListener ~>
  func success(todo: Todo)
  func failed(err: string)
end

open trait TodoListener ~>
  func punch(listener: TodoPunchListener) -> boolean
end

open impl TodoImpl : TodoListener ~>
  override func punch(listener: TodoPunchListener) ~>
    if (1 + 1 == 2) -> listener.success(
      new Todo('test', 23)
    )
    else -> 
      listener.failed('can not punched !!')
    return true
  end
end

open impl Test : TodoPunchListener ~>
  init -> new TodoImpl().punch(this)

  override func success(todo: Todo) => println '\(todo.title) \(todo.date)'

  override func failed(err: string) => println 'Error: \(err)'
end

open enum Color -> RED, BLUE, GREEN

var a = Color.RED

impl A ~>
  open func show() => println 'show !!'
end

impl B : A ~>
  init -> super.show()
end

new B()

var a = 23
var b = 45
var c = (a: int) => println a

c(a) // The variable a is null, because the a is transmit to function parameter.

if (a == null) ->
  println 'a is null !!'

// The c is function with a ref use parameter.
// if 
var c = (ref a: int) => println a

open const var a = (12, 43, 45, 65)

println a.0 + a.1 + a.2 + a.3 // 165

func max (ref a: int, ref b: int) -> int => if (a > b) -> a else -> b

var mut a = 0
var mut b = []

for (i <- 1..100) ~>
  if (i % 2 == 0) ~>
    b.insert(i)
    continue
  end
  a += 1
end

println a
println b
